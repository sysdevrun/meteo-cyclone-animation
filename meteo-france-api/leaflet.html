<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyclone Trajectory Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        #map {
            height: 500px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        #dateDisplay {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 10px;
            font-weight: 500;
            text-align: center;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border-radius: 10px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #667eea;
            font-size: 1.1em;
            font-weight: 500;
        }

        .controls {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 600;
            color: #333;
            min-width: 120px;
        }

        input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s;
            flex: 1;
            min-width: 200px;
        }

        input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        #playPauseBtn {
            background: #28a745;
        }

        #playPauseBtn:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        #restartBtn {
            background: #007bff;
        }

        #restartBtn:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        #loopBtn {
            background: #6c757d;
        }

        #loopBtn.active {
            background: #ffc107;
        }

        #loopBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        #loopBtn.active:hover {
            background: #e0a800;
        }

        .speed-display {
            color: #667eea;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        .info {
            text-align: center;
            margin: 10px 0;
            color: #666;
            font-size: 0.9em;
        }

        .error {
            color: #dc3545;
            font-weight: 600;
            text-align: center;
            padding: 20px;
        }

        .map-container {
            position: relative;
        }

        .legend {
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }

        .cyclone-info {
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 0.9em;
            max-width: 250px;
        }

        .cyclone-info h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .cyclone-info p {
            margin: 4px 0;
            color: #666;
        }

        .cyclone-info strong {
            color: #333;
        }

        .report-section {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .report-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .report-content {
            font-size: 0.95em;
            line-height: 1.6;
            color: #444;
        }

        .report-content .bloc-title {
            font-weight: 700;
            color: #333;
            margin-top: 15px;
            margin-bottom: 8px;
        }

        .report-content .text-line {
            margin: 5px 0;
        }

        .report-content .separator {
            border-top: 1px dashed #ccc;
            margin: 15px 0;
        }

        .no-report {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .forecast-label {
            background: none;
            border: none;
            font-size: 9px;
            color: #333;
            white-space: nowrap;
        }

        .data-source {
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.95em;
            color: #666;
        }

        .data-source a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .data-source a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Cyclone Trajectory Map</h1>
        <div class="data-source">DonnÃ©es <a href="https://meteofrance.re/fr/cyclone" target="_blank" rel="noopener">MÃ©tÃ©o-France</a></div>

        <div class="controls">
            <div class="control-group">
                <label for="speedSlider">Animation speed:</label>
                <input type="range" id="speedSlider" min="100" max="3000" step="100" value="1000">
                <span class="speed-display"><span id="speedDisplay">1000</span> ms</span>
            </div>

            <div class="control-group">
                <label for="snapshotSlider">Snapshot:</label>
                <input type="range" id="snapshotSlider" min="0" max="0" step="1" value="0" disabled>
                <span class="speed-display"><span id="snapshotPosition">0</span> / <span id="snapshotTotal">0</span></span>
            </div>
        </div>

        <div class="viewer">
            <div class="buttons">
                <button id="playPauseBtn" onclick="togglePlayPause()" disabled>â–¶ Play</button>
                <button id="restartBtn" onclick="restartAnimation()" disabled>â†» Restart</button>
                <button id="loopBtn" onclick="toggleLoop()">âˆž Loop: OFF</button>
            </div>

            <div class="info">
                <p>Frame: <strong><span id="frameCounter">0</span> / <span id="totalFrames">0</span></strong></p>
            </div>

            <div id="dateDisplay">Loading...</div>
            <div class="map-container">
                <div id="map"></div>
                <div id="loadingOverlay" class="loading-overlay">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="loadingText">Loading data...</div>
                </div>
            </div>
        </div>

        <div class="report-section" id="reportSection" style="display: none;">
            <h2>ðŸ“‹ Cyclone Activity Report</h2>
            <div class="report-content" id="reportContent"></div>
        </div>
    </div>

    <script>
        // State
        let snapshotMetadata = [];  // Metadata from api_data.json
        let loadedSnapshots = {};   // Cache for loaded snapshot data
        let currentIndex = 0;
        let isPlaying = false;
        let isLooping = false;
        let animationInterval = null;
        let speed = 1000;
        let hasInitiallyCentered = false;  // Track if map has been centered on first load

        // Map layers
        let map;
        let analysisLayer;
        let forecastLayer;
        let uncertaintyLayer;
        let pathLayer;

        // DOM elements
        const dateDisplay = document.getElementById('dateDisplay');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const loopBtn = document.getElementById('loopBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const frameCounter = document.getElementById('frameCounter');
        const totalFrames = document.getElementById('totalFrames');
        const snapshotSlider = document.getElementById('snapshotSlider');
        const snapshotPosition = document.getElementById('snapshotPosition');
        const snapshotTotal = document.getElementById('snapshotTotal');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const reportSection = document.getElementById('reportSection');
        const reportContent = document.getElementById('reportContent');

        // Development stages color mapping
        const developmentColors = {
            'disturbance': '#90EE90',
            'tropical disturbance': '#98FB98',
            'tropical depression': '#00BFFF',
            'moderate tropical storm': '#FFD700',
            'severe tropical storm': '#FFA500',
            'tropical cyclone': '#FF4500',
            'intense tropical cyclone': '#DC143C',
            'post-tropical depression': '#808080'
        };

        // Initialize map
        function initMap() {
            map = L.map('map').setView([-17, 77], 5);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Initialize layer groups
            uncertaintyLayer = L.layerGroup().addTo(map);
            pathLayer = L.layerGroup().addTo(map);
            analysisLayer = L.layerGroup().addTo(map);
            forecastLayer = L.layerGroup().addTo(map);

            // Add legend
            const legend = L.control({ position: 'bottomright' });
            legend.onAdd = function() {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0066CC;"></div>
                        <span>Analysis (observed)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #CC0000;"></div>
                        <span>Forecast</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255, 165, 0, 0.3); border: 1px solid orange;"></div>
                        <span>Uncertainty cone</span>
                    </div>
                `;
                return div;
            };
            legend.addTo(map);
        }

        // Load metadata from api_data.json
        async function loadData() {
            try {
                loadingText.textContent = 'Loading metadata...';

                const response = await fetch('api_data.json');
                if (!response.ok) {
                    throw new Error('Failed to load api_data.json');
                }

                snapshotMetadata = await response.json();

                if (!Array.isArray(snapshotMetadata) || snapshotMetadata.length === 0) {
                    throw new Error('No snapshot data found');
                }

                // Sort by timestamp
                snapshotMetadata.sort((a, b) => a.timestamp - b.timestamp);

                // Update UI
                totalFrames.textContent = snapshotMetadata.length;
                snapshotTotal.textContent = snapshotMetadata.length;
                snapshotSlider.max = snapshotMetadata.length - 1;
                snapshotSlider.disabled = false;
                playPauseBtn.disabled = false;
                restartBtn.disabled = false;

                // Hide loading overlay
                loadingOverlay.style.display = 'none';

                // Display first snapshot
                await displaySnapshot(0);

            } catch (error) {
                console.error('Error loading data:', error);
                loadingText.textContent = 'Error: ' + error.message;
                loadingText.style.color = '#dc3545';
            }
        }

        // Fetch snapshot data from files
        async function fetchSnapshotData(metadata) {
            const cacheKey = metadata.timestamp;

            // Return cached data if available
            if (loadedSnapshots[cacheKey]) {
                return loadedSnapshots[cacheKey];
            }

            // Fetch trajectories
            const trajectories = [];
            for (const trajectoryFile of metadata.trajectory_files) {
                const response = await fetch(trajectoryFile);
                if (response.ok) {
                    const trajectory = await response.json();
                    trajectories.push(trajectory);
                }
            }

            // Fetch report if available
            let report = null;
            if (metadata.report_file) {
                const response = await fetch(metadata.report_file);
                if (response.ok) {
                    report = await response.json();
                }
            }

            // Create snapshot object
            const snapshot = {
                timestamp: metadata.timestamp,
                date: metadata.date,
                trajectories,
                report
            };

            // Cache the loaded data
            loadedSnapshots[cacheKey] = snapshot;

            return snapshot;
        }

        // Fit map bounds to trajectory
        function fitMapToTrajectory(trajectory) {
            const bounds = [];

            for (const feature of trajectory.features) {
                if (feature.geometry.type === 'Point') {
                    const [lon, lat] = feature.geometry.coordinates;
                    bounds.push([lat, lon]);
                } else if (feature.geometry.type === 'Polygon') {
                    for (const ring of feature.geometry.coordinates) {
                        for (const [lon, lat] of ring) {
                            bounds.push([lat, lon]);
                        }
                    }
                }
            }

            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // Get color based on development stage
        function getColor(development) {
            return developmentColors[development] || '#808080';
        }

        // Format wind speed
        function formatWind(kt) {
            const kmh = Math.round(kt * 1.852);
            return `${kt} kt (${kmh} km/h)`;
        }

        // Format date for forecast label (DD/MM â€” HHh UTC)
        function formatForecastDate(isoDate) {
            const date = new Date(isoDate);
            const day = String(date.getUTCDate()).padStart(2, '0');
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            return `${day}/${month} â€” ${hours}h`;
        }

        // Format date for popup (DD/MM/YYYY HH:MM)
        function formatPopupDate(isoDate) {
            const date = new Date(isoDate);
            const day = String(date.getUTCDate()).padStart(2, '0');
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const year = date.getUTCFullYear();
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Create popup content for a point
        function createPopupContent(properties, isAnalysis) {
            const data = properties.cyclone_data;
            const type = isAnalysis ? 'Analysis' : 'Forecast';

            let content = `
                <div class="cyclone-info">
                    <h3>${type}</h3>
                    <p><strong>Time:</strong> ${formatPopupDate(properties.time)}</p>
                    <p><strong>Development:</strong> ${data.development || 'N/A'}</p>
            `;

            if (data.minimum_pressure !== undefined) {
                content += `<p><strong>Pressure:</strong> ${data.minimum_pressure} hPa</p>`;
            }

            content += `
                    <p><strong>Max wind:</strong> ${formatWind(data.maximum_wind.wind_speed_kt)}</p>
                    <p><strong>Gusts:</strong> ${formatWind(data.maximum_wind.wind_speed_gust_kt)}</p>
            `;

            if (data.Dvorak) {
                content += `<p><strong>Dvorak T:</strong> ${data.Dvorak.final_T_number}</p>`;
            }

            content += '</div>';
            return content;
        }

        // Display a single trajectory on the map
        function displayTrajectoryOnMap(trajectory) {
            // Clear existing layers
            analysisLayer.clearLayers();
            forecastLayer.clearLayers();
            uncertaintyLayer.clearLayers();
            pathLayer.clearLayers();

            // Separate features by type
            const analysisPoints = [];
            const forecastPoints = [];
            let uncertaintyCone = null;

            for (const feature of trajectory.features) {
                const dataType = feature.properties.data_type;

                if (dataType === 'analysis') {
                    analysisPoints.push(feature);
                } else if (dataType === 'forecast') {
                    forecastPoints.push(feature);
                } else if (dataType === 'uncertainty_cone') {
                    uncertaintyCone = feature;
                }
            }

            // Draw uncertainty cone first (so it's behind everything)
            if (uncertaintyCone) {
                const coords = uncertaintyCone.geometry.coordinates[0].map(([lon, lat]) => [lat, lon]);
                L.polygon(coords, {
                    color: 'orange',
                    weight: 2,
                    fillColor: 'orange',
                    fillOpacity: 0.2
                }).addTo(uncertaintyLayer);
            }

            // Draw path lines
            if (analysisPoints.length > 0) {
                const analysisCoords = analysisPoints.map(f => {
                    const [lon, lat] = f.geometry.coordinates;
                    return [lat, lon];
                });
                L.polyline(analysisCoords, {
                    color: '#0066CC',
                    weight: 3,
                    opacity: 0.8
                }).addTo(pathLayer);
            }

            if (forecastPoints.length > 0) {
                const forecastCoords = forecastPoints.map(f => {
                    const [lon, lat] = f.geometry.coordinates;
                    return [lat, lon];
                });

                // Connect last analysis to first forecast
                if (analysisPoints.length > 0) {
                    const lastAnalysis = analysisPoints[analysisPoints.length - 1];
                    const firstForecast = forecastPoints[0];
                    const [lon1, lat1] = lastAnalysis.geometry.coordinates;
                    const [lon2, lat2] = firstForecast.geometry.coordinates;
                    L.polyline([[lat1, lon1], [lat2, lon2]], {
                        color: '#CC0000',
                        weight: 3,
                        opacity: 0.8,
                        dashArray: '5, 5'
                    }).addTo(pathLayer);
                }

                L.polyline(forecastCoords, {
                    color: '#CC0000',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '5, 5'
                }).addTo(pathLayer);
            }

            // Draw analysis points
            for (const feature of analysisPoints) {
                const [lon, lat] = feature.geometry.coordinates;
                const development = feature.properties.cyclone_data?.development;

                const marker = L.circleMarker([lat, lon], {
                    radius: 3,
                    fillColor: getColor(development),
                    color: '#0066CC',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });

                marker.bindPopup(createPopupContent(feature.properties, true));
                marker.addTo(analysisLayer);
            }

            // Draw forecast points with date labels
            for (const feature of forecastPoints) {
                const [lon, lat] = feature.geometry.coordinates;
                const development = feature.properties.cyclone_data?.development;

                const marker = L.circleMarker([lat, lon], {
                    radius: 4,
                    fillColor: getColor(development),
                    color: '#CC0000',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.6
                });

                marker.bindPopup(createPopupContent(feature.properties, false));
                marker.addTo(forecastLayer);

                // Add date label next to forecast circle
                const dateLabel = formatForecastDate(feature.properties.time);
                const labelIcon = L.divIcon({
                    className: 'forecast-label',
                    html: dateLabel,
                    iconSize: null,
                    iconAnchor: [-8, 6]
                });
                L.marker([lat, lon], { icon: labelIcon, interactive: false }).addTo(forecastLayer);
            }

            return { analysisPoints, forecastPoints };
        }

        // Display snapshot
        async function displaySnapshot(index) {
            if (snapshotMetadata.length === 0) return;

            const metadata = snapshotMetadata[index];

            // Fetch the actual snapshot data
            const snapshot = await fetchSnapshotData(metadata);

            // Get first trajectory (or handle multiple)
            if (snapshot.trajectories.length === 0) {
                dateDisplay.textContent = `${snapshot.date} - No active cyclones`;
                reportSection.style.display = 'none';
                return;
            }

            const firstTrajectory = snapshot.trajectories[0].cyclone_trajectory;
            const { analysisPoints } = displayTrajectoryOnMap(firstTrajectory);

            // Update display info
            const cycloneNames = snapshot.trajectories.map(t => t.cyclone_trajectory.cyclone_name).join(', ');
            dateDisplay.textContent = `${cycloneNames} - ${snapshot.date}`;
            frameCounter.textContent = index + 1;
            snapshotSlider.value = index;
            snapshotPosition.textContent = index + 1;

            // Update cyclone info panel
            updateCycloneInfo(firstTrajectory, analysisPoints);

            // Display report if present
            displayReport(snapshot.report);

            // Fit map to trajectory on first display only
            if (index === 0 && !hasInitiallyCentered) {
                fitMapToTrajectory(firstTrajectory);
                hasInitiallyCentered = true;
            }
        }

        // Update cyclone info panel
        function updateCycloneInfo(trajectory, analysisPoints) {
            // Remove existing info control
            const existingInfo = document.querySelector('.leaflet-top.leaflet-left .cyclone-info');
            if (existingInfo) {
                existingInfo.parentElement.remove();
            }

            // Get latest analysis data
            const latestAnalysis = analysisPoints[analysisPoints.length - 1];
            if (!latestAnalysis) return;

            const cycloneData = latestAnalysis.properties.cyclone_data;

            const info = L.control({ position: 'topleft' });
            info.onAdd = function() {
                const div = L.DomUtil.create('div', 'cyclone-info');
                div.innerHTML = `
                    <h3>ðŸŒ€ ${trajectory.cyclone_name}</h3>
                    <p><strong>Status:</strong> ${cycloneData.development || 'N/A'}</p>
                    <p><strong>Pressure:</strong> ${cycloneData.minimum_pressure} hPa</p>
                    <p><strong>Max wind:</strong> ${formatWind(cycloneData.maximum_wind.wind_speed_kt)}</p>
                    <p><strong>Update:</strong> ${new Date(trajectory.reference_time).toLocaleString()}</p>
                `;
                return div;
            };
            info.addTo(map);
        }

        // Display report
        function displayReport(report) {
            if (!report) {
                reportSection.style.display = 'none';
                return;
            }

            reportSection.style.display = 'block';

            let html = '';

            for (const item of report.text_bloc_item) {
                if (item.bloc_title) {
                    html += `<div class="bloc-title">${item.bloc_title}</div>`;
                } else if (item.text) {
                    if (item.text === '-------------------------------------------------') {
                        html += '<div class="separator"></div>';
                    } else if (item.text.trim()) {
                        html += `<div class="text-line">${item.text}</div>`;
                    }
                }
            }

            reportContent.innerHTML = html;
        }

        // Animation loop
        async function animate() {
            if (!isPlaying) return;

            currentIndex++;

            if (currentIndex >= snapshotMetadata.length) {
                if (isLooping) {
                    currentIndex = 0;
                } else {
                    stopAnimation();
                    return;
                }
            }

            await displaySnapshot(currentIndex);
        }

        // Start animation
        function startAnimation() {
            if (snapshotMetadata.length === 0) return;

            isPlaying = true;
            playPauseBtn.innerHTML = 'â¸ Pause';
            animationInterval = setInterval(animate, speed);
        }

        // Stop animation
        function stopAnimation() {
            isPlaying = false;
            playPauseBtn.innerHTML = 'â–¶ Play';
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        // Toggle play/pause
        function togglePlayPause() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        // Restart animation from beginning
        async function restartAnimation() {
            currentIndex = 0;
            await displaySnapshot(currentIndex);

            if (!isPlaying) {
                startAnimation();
            }
        }

        // Toggle loop mode
        function toggleLoop() {
            isLooping = !isLooping;
            loopBtn.textContent = 'âˆž Loop: ' + (isLooping ? 'ON' : 'OFF');
            loopBtn.classList.toggle('active');
        }

        // Update speed
        speedSlider.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            speedDisplay.textContent = speed;

            // Restart interval with new speed if playing
            if (isPlaying) {
                clearInterval(animationInterval);
                animationInterval = setInterval(animate, speed);
            }
        });

        // Snapshot slider control
        snapshotSlider.addEventListener('input', async (e) => {
            currentIndex = parseInt(e.target.value);

            // Pause animation when manually scrubbing
            if (isPlaying) {
                stopAnimation();
            }

            await displaySnapshot(currentIndex);
        });

        // Initialize
        initMap();
        loadData();
    </script>
</body>
</html>
